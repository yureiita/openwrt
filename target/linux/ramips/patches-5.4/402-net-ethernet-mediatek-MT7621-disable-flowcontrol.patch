--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -22,6 +22,10 @@
 
 #include "mt7530.h"
 
+#ifdef CONFIG_SOC_MT7621
+#define DISABLE_MTK_FC  // disable flow control for mt7621 soc
+#endif
+
 /* String, offset, and register size in bytes if different from 4 bytes */
 static const struct mt7530_mib_desc mt7530_mib[] = {
 	MIB_DESC(1, 0x00, "TxDrop"),
@@ -1278,6 +1282,18 @@ mt7530_setup(struct dsa_switch *ds)
 	val |= MHWTRAP_MANUAL;
 	mt7530_write(priv, MT7530_MHWTRAP, val);
 
+	/* MT7621 a bug prevents Flow Control to work reliably; so for now we disable it */
+#ifdef DISABLE_MTK_FC
+	usleep_range(10, 20);
+
+	val = mt7530_read(priv, 0x1FE0);
+	val &= ~BIT(31);
+	mt7530_write(priv, 0x1FE0, val);
+
+	mt7530_write(priv, MT7530_PMCR_P(5), 0x5e30b);
+	mt7530_write(priv, MT7530_PMCR_P(6), 0x5e30b);
+	usleep_range(10, 20);
+#endif
 	priv->p6_interface = PHY_INTERFACE_MODE_NA;
 
 	/* Enable and reset MIB counters */
@@ -1395,8 +1411,12 @@ static void mt7530_phylink_mac_config(st
 
 	mcr_cur = mt7530_read(priv, MT7530_PMCR_P(port));
 	mcr_new = mcr_cur;
+#ifdef DISABLE_MTK_FC
+	mcr_new &= ~(PMCR_FORCE_SPEED_1000 | PMCR_FORCE_SPEED_100 | PMCR_FORCE_FDX);
+#else
 	mcr_new &= ~(PMCR_FORCE_SPEED_1000 | PMCR_FORCE_SPEED_100 |
 		     PMCR_FORCE_FDX | PMCR_TX_FC_EN | PMCR_RX_FC_EN);
+#endif
 	mcr_new |= PMCR_IFG_XMIT(1) | PMCR_MAC_MODE | PMCR_BACKOFF_EN |
 		   PMCR_BACKPR_EN | PMCR_FORCE_MODE;
 
@@ -1416,14 +1436,20 @@ static void mt7530_phylink_mac_config(st
 			mcr_new |= PMCR_FORCE_EEE100;
 		break;
 	}
+
+#ifdef DISABLE_MTK_FC
 	if (state->duplex == DUPLEX_FULL) {
 		mcr_new |= PMCR_FORCE_FDX;
+	}
+#else
+	if (state->duplex == DUPLEX_FULL) {
+ 		mcr_new |= PMCR_FORCE_FDX;
 		if (state->pause & MLO_PAUSE_TX)
 			mcr_new |= PMCR_TX_FC_EN;
 		if (state->pause & MLO_PAUSE_RX)
 			mcr_new |= PMCR_RX_FC_EN;
-	}
-
+ 	}
+#endif
 	if (mcr_new != mcr_cur)
 		mt7530_write(priv, MT7530_PMCR_P(port), mcr_new);
 }
@@ -1502,9 +1528,10 @@ unsupported:
 		}
 	}
 
+#ifndef DISABLE_MTK_FC
 	phylink_set(mask, Pause);
 	phylink_set(mask, Asym_Pause);
-
+#endif
 	linkmode_and(supported, supported, mask);
 	linkmode_and(state->advertising, state->advertising, mask);
 }
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -26,6 +26,10 @@
 
 #include "mtk_eth_soc.h"
 
+#ifdef CONFIG_SOC_MT7621
+#define DISABLE_MTK_FC // disable flow control for mt7621 soc
+#endif
+
 static int mtk_msg_level = -1;
 module_param_named(msg_level, mtk_msg_level, int, 0);
 MODULE_PARM_DESC(msg_level, "Message level (-1=defaults,0=none,...,16=all)");
@@ -372,13 +376,19 @@ static void mtk_mac_config(struct phylin
 		mcr_new |= MAC_MCR_SPEED_100;
 		break;
 	}
+#ifdef DISABLE_MTK_FC
 	if (state->duplex == DUPLEX_FULL) {
 		mcr_new |= MAC_MCR_FORCE_DPX;
+	}
+#else
+	if (state->duplex == DUPLEX_FULL) {
+ 		mcr_new |= MAC_MCR_FORCE_DPX;
 		if (state->pause & MLO_PAUSE_TX)
 			mcr_new |= MAC_MCR_FORCE_TX_FC;
 		if (state->pause & MLO_PAUSE_RX)
 			mcr_new |= MAC_MCR_FORCE_RX_FC;
-	}
+ 	}
+#endif
 
 	/* Only update control register when needed! */
 	if (mcr_new != mcr_cur)
@@ -421,13 +431,17 @@ static int mtk_mac_link_state(struct phy
 		break;
 	}
 
+#ifdef DISABLE_MTK_FC
+	return 1;
+#else
 	state->pause &= (MLO_PAUSE_RX | MLO_PAUSE_TX);
 	if (pmsr & MAC_MSR_RX_FC)
 		state->pause |= MLO_PAUSE_RX;
 	if (pmsr & MAC_MSR_TX_FC)
 		state->pause |= MLO_PAUSE_TX;
 
-	return 1;
+ 	return 1;
+#endif
 }
 
 static void mtk_mac_an_restart(struct phylink_config *config)
@@ -535,9 +549,10 @@ static void mtk_validate(struct phylink_
 		}
 	}
 
+#ifndef DISABLE_MTK_FC
 	phylink_set(mask, Pause);
 	phylink_set(mask, Asym_Pause);
-
+#endif
 	linkmode_and(supported, supported, mask);
 	linkmode_and(state->advertising, state->advertising, mask);
 
